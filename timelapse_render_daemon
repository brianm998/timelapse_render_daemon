#!/usr/bin/perl

# this script runs as a daemon to watch for timlapse sequences to render
# into videos, and renders them when they are ready, showing a running status
# update of what's going on.

use strict;
use File::Basename;
use Cwd;
use JSON;

my $script_dir;	# figure out where this running script exists on disk
BEGIN { $script_dir = Cwd::realpath( File::Basename::dirname(__FILE__)) }

# add this dir to the include path
use lib "${script_dir}/inc";

use Renderer;
use UpdateableLog;
use ExiftoolRunner;
use DebugLog;

use lib '/Users/brian/git/timelapse_image_blender/inc'; # XXX fuck :(
use Timelapse;
use Exiftool;

# logic:
# read source path dirs and keep a record of name of dir and # of images

# look into temp_paths and try to find paths that match the name from
# source_dir, and have the right number of fully written output files,
# and don't have videos rendered in the temp or master_videos dirs with
# the same names as the config would end up producing

# once identified, render one or more videos based upon the config
# after each render, check to see if there is an exif json file for the
# source image sequence, if not, create it.
# apply this exif json file to the rendered videos

# keep running in daemon mode forever


# startup:

# - read source_dir, get initial list of image sequences and lengths


# daemon loop:

# - read source_dir, updating info on sequences and lengths
# - traverse temp_paths, looking for non-rendered videos
# - render non-existant videos
# - make json exif file if non existant
# - embed that into video

# todo:

# - detangle depenency inc mess
# - support {year} in dirs?
# - notice when existing master video is older than the new sequence, and still render to temp path, assuming no file at temp path exists yet
# - allow rendering when base image sequence has been archived, based upon # of images from json
#   - specify archive locations in config
# - fix problem where deleting dirs makes them show up (tmp_rm hack works for now, kindof)
# - add validation for Timelapse and others (ffmpeg exists, etc)
# - watch updates in config.json and update when running
# - write a real log file as well as the refreshing  console output
# - add config validation
# - avoid printing lines longer than the console
# - have timeLog not update time on log when message is the same
# - check to see running on macos and run caffeinate to keep alive in background
# - allow re-reading config every so often (add validation first)
# - introduce a state system to track where image sequences are
#   (would help with being able to not log about deleting sequences)

# all user visible output goes through this log
my $log = UpdateableLog->new();
#my $log = DebugLog->new();

# allow json config file to be referenced on the command line
my $config_json_filename = shift;

unless(defined $config_json_filename) {
  # if no config given on command line, default to this
  if(-e "$script_dir/config.json") {
    $config_json_filename = "$script_dir/config.json";
  } else {
    # XXX die with usage if no config present
    die;
  }
}

my $config = read_json_from($config_json_filename);

die unless ($config);
# XXX validate it

# an addressable list of what codecs we can encode to
$config->{codecs} = read_json_from("$script_dir/video_codecs.json");
# XXX validate that this is there and in right format
die unless ($config->{codecs});

# run once without renders to fully flesh out the display
search_and_discover($config, 1);

my $max_cuncurrent_renders = $config->{max_cuncurrent_renders};
$max_cuncurrent_renders = 1 unless defined $max_cuncurrent_renders;

my $current_renders = 0;

my $max_exiftools = 200;
my $current_exiftools = 0;

while(1) {
  # search again and populate the render map
  search_and_discover($config, 0);

  process_render_map($config);

  process_exif_list($config);

  sleep($config->{sleep_time_seconds})
    if($current_renders == 0 && $current_exiftools == 0);
}

########
# subs #
########

# handle the render map
# if any keys are present, each iteration will then:
#  - remove any done renderers from the map
#  - maybe start some new renderers
#  - have all other renderers process one more line of ffmpeg output
sub process_render_map($) {
  my ($config) = @_;

  if(scalar(keys %{$config->{renderer_map}}) > 0) {
    # we've got some active Renderer objects
    foreach my $output_video_filename (keys %{$config->{renderer_map}}) {
      my $renderer = $config->{renderer_map}{$output_video_filename};
      if($renderer->{is_done}) {
	# get rid of renderers that are done
	delete $config->{renderer_map}{$output_video_filename};
	$current_renders--;
      } elsif(!$renderer->{is_running}) {
	# if not done and not running, maybe start it
	if ($current_renders < $max_cuncurrent_renders) {
	  $renderer->start();	# XXX check max
	  $current_renders++;
	}
      } else {
	# not done and still running, read output to update display
	$renderer->render_frame();
      }
    }
  }
}

# handle the exif map
# if any keys are present, each iteration will then:
#  - remove any done exiftools from the map
#  - maybe start some new exiftools
#  - have all other exiftools process one more line of exiftool output
sub process_exif_list($) {
  my ($config) = @_;

  if(scalar(keys %{$config->{exif_list}}) > 0) {
    # there is some exiftool action happening
    foreach my $exiftool_filename (keys %{$config->{exif_list}}) {
      my $exiftool = $config->{exif_list}{$exiftool_filename};
      if($exiftool->{is_done}) {
	delete $config->{exif_list}{$exiftool_filename};
	$current_exiftools--;
      } elsif(!$exiftool->{is_running}) {
	if($current_exiftools < $max_exiftools) {
	  $exiftool->start();
	  $current_exiftools++;
	}
      } else {
	$exiftool->read();
      }
    }
  }
}

# look for image sequences that might be ready to render
sub search_and_discover($$$) {
  my ($config, $no_render, $currently_rendering_sequence_name) = @_;

  # a hash of all raw image sequences to their number of raw images
  my $raw_image_sequence_counts = count_raw_image_sequences($config);

  # search each path where processed frame images are written to
  foreach my $temp_path (@{$config->{temp_paths}}) {
    opendir my $temp_dir, $temp_path or die "cannot open $temp_path: $!\n";

    search_and_discover_from_temp_dir($config, $no_render,
				    $currently_rendering_sequence_name,
				    $raw_image_sequence_counts,
				    $temp_dir, $temp_path);

    closedir $temp_dir;
  }
}

# look into a specific temp dir for image sequences that might be ready to render
sub search_and_discover_from_temp_dir($$$$$$) {
  my ($config, $no_render, $currently_rendering_sequence_name,
      $raw_image_sequence_counts, $temp_dir, $temp_path) = @_;

  foreach my $image_sequence_dirname (readdir $temp_dir) {
    next unless(-d "$temp_path/$image_sequence_dirname");
    my $raw_image_sequence_name = undef;

    my $raw_sequence_length = undef;
    my $base_dirname = undef;  # the dirname of the raw image sequence

    # look for a raw image sequence that may have been used to generate this image sequence
    foreach my $dirname (keys %$raw_image_sequence_counts) {
      foreach my $raw_image_sequence (keys %{$raw_image_sequence_counts->{$dirname}}) {
	if ($image_sequence_dirname =~ /$config->{image_sequence_dirname_prefix}$raw_image_sequence/) {
	  $raw_image_sequence_name = $raw_image_sequence;
	  $raw_sequence_length = $raw_image_sequence_counts->{$dirname}{$raw_image_sequence_name};
	  $base_dirname = $dirname;
	}
      }
    }
    # we need to know the $raw_image_sequence_name for this generated image sequence
    next unless defined $raw_image_sequence_name;

    process_image_sequence($config, $no_render,
			   $currently_rendering_sequence_name,
			   $temp_dir, $temp_path, $image_sequence_dirname,
			   $raw_sequence_length, $base_dirname, $raw_image_sequence_name);
  }
}

# check the status of an identified image sequence
# maybe render, or just log
sub process_image_sequence($$$$$$) {

  my ($config, $no_render, $currently_rendering_sequence_name,
      $temp_dir, $temp_path, $image_sequence_dirname,
      $raw_sequence_length, $base_dirname, $raw_image_sequence_name) = @_;

  # check number of generated images present
  opendir my $temp_dir, "$temp_path/$image_sequence_dirname" or die "cannot open dfs dir: $!\n";
  my $number_of_generated_images = 0;
  foreach my $entry (readdir $temp_dir) {
    next if($entry =~ /^[.]/);
    next unless (-f "$temp_path/$image_sequence_dirname/$entry"); # only files
    # files with .tif or .tiff extensions only
    if ($entry !~ /[.]tiff?$/) { # XXX expose this in config so jpeg works too
      next;
    }
    # what about jpeg?
    $number_of_generated_images++; # assume everything else is an image
  }
  closedir $temp_dir;

  if ($number_of_generated_images == $raw_sequence_length) {
    # this image sequence has the same length as the raw sequence
    my $would_render = undef;

    foreach my $render_type (@{$config->{rendering}}) {
      my $output_video_filename = output_video_filename($config,
							$render_type,
							$image_sequence_dirname);
      my $should_render = should_render($config, $output_video_filename);

      if (defined $would_render) {
	$would_render = $should_render || $would_render;
      } else {
	$would_render = $should_render;
      }
    }
    return unless($would_render);

    unless ($currently_rendering_sequence_name eq $image_sequence_dirname) {
      my $sequence_size = Renderer::sizeStringOf("$temp_path/$image_sequence_dirname");
      if(-e "$temp_path/$image_sequence_dirname.json") {
	$log->timeLog($image_sequence_dirname, "$sequence_size $raw_sequence_length frame image sequence $temp_path/$image_sequence_dirname is ready to render", 1);
      }
    }

    return if($no_render);

    # actually try to render
    render_all_videos_for_image_sequence($config,
					 $temp_path,
					 $image_sequence_dirname,
					 $base_dirname,
					 $raw_image_sequence_name,
					 $raw_sequence_length)
  } else {
    # cannot process this one yet, not enough images
    # log of how far along it is

    my $percentage = $number_of_generated_images / $raw_sequence_length;
    my $progress_bar = Renderer::progress_bar(30,  $percentage);

    my $frames_left = $raw_sequence_length - $number_of_generated_images;
    my $msg = sprintf("(%04.d / %04.d) %04.d more",
		      $number_of_generated_images, $raw_sequence_length,  $frames_left);
    my $sequence_size = Renderer::sizeStringOf("$temp_path/$image_sequence_dirname");

    # XXX this is a hack to align layers. usually 4 chars, add another when 3
    $sequence_size = " $sequence_size" if(length($sequence_size) == 3);

    $log->log($image_sequence_dirname, "$progress_bar $msg - $sequence_size $temp_path/$image_sequence_dirname", $percentage);
  }
}

# reads all the raw image sequences based upon the config
# and returns a hash of source path/entry to raw image count
sub count_raw_image_sequences($) {

  my ($config) = @_;

  my $raw_image_sequence_counts = {};
  foreach my $source_path (@{$config->{source_paths}}) {
    opendir my $source_dir, $source_path or die "cannot open fuck $source_path: $!\n";

    foreach my $source_entry (readdir $source_dir) {
      next if($source_entry =~ /^[.]/);
      next unless(-d "$source_path/$source_entry");

      my $raw_image_count = 0;
      opendir my $entry_dir, "$source_path/$source_entry" or die "cannot open shit dir: $!\n";

      foreach my $entry (readdir $entry_dir) {
	my $keep = 0;
	foreach my $raw_type (@{$config->{raw_types}}) {
	  $keep = 1 if($entry =~ /[.]$raw_type$/);
	}
	next unless $keep;
	$raw_image_count++;
      }

      $raw_image_sequence_counts->{$source_path}{$source_entry} = $raw_image_count;
    }
    closedir $source_dir;
  }
  return $raw_image_sequence_counts;
}

sub render_all_videos_for_image_sequence() {
  my ($config,
      $temp_path,
      $image_sequence_dirname,
      $base_dirname,
      $raw_image_sequence_name,
      $raw_sequence_length) = @_;

  # check here to see if we have an exif json file for this image sequence,
  # if not, create it, and return the collected exif values to to pass to ffmpeg
  my $image_sequence_exif = read_exif_json($image_sequence_dirname,
					   $base_dirname,
					   $raw_image_sequence_name);

  return unless defined $image_sequence_exif;

  my $sequence_size = Renderer::sizeStringOf("$temp_path/$image_sequence_dirname");

  $log->timeLog($image_sequence_dirname, "rendering videos from $sequence_size image sequence $temp_path/$image_sequence_dirname", 10);

  my $group = [];		# these renderers all share a group

  my $finished_callback = sub($) {
    my ($self) = @_;
    # called when this group is done rendering

    if ($self->{result}) {
#      my $sequence_size = Renderer::sizeStringOf("$self->{output_dirname}/$self->{image_sequence_name}");
      # maybe delete the image sequence after successful render
      my $removed = 0;
      foreach my $delete_regex (@{$self->{config}{delete_sequence_after_render_regexes}}) {
	if ("$self->{output_dirname}/$self->{image_sequence_name}" =~ /$delete_regex/) {
	  my $rm_cmd = "rm -rf $self->{output_dirname}/$self->{image_sequence_name}";
	  $self->{log}->timeLog($self->{image_sequence_name}, "running $rm_cmd", 10);
	  system($rm_cmd);
	  $removed = 1;
	  $self->{log}->timeLog($self->{image_sequence_name}, "done rendering videos from $sequence_size image sequence $self->{output_dirname}/$self->{image_sequence_name}, image sequence removed", -1);
	}
      }
      unless ($removed) {
	# potential bug where this doesn't show up when only
	# some videos needed to be rendered
	$self->{log}->timeLog($self->{image_sequence_name}, "done rendering videos from $sequence_size image sequence $self->{output_dirname}/$self->{image_sequence_name}", -1);
      }
    } else {
      $self->{log}->timeLog($self->{image_sequence_name}, "appears to have failed :(", -1);
    }
  };

  foreach my $render_type (@{$config->{rendering}}) {
    create_renderer($config, $temp_path,
		    $image_sequence_dirname,
		    $image_sequence_exif,
		    $raw_sequence_length,
		    $render_type,
		    $group,
		    $finished_callback);
  }
}

# returns the name of the video file that would be output
sub output_video_filename($$$) {
  my ($config, $render_type, $image_sequence_name) = @_;

  my $output_video_filename = $image_sequence_name;
  # remove the sequence image prefex if it happens to be part of the video filename
  while($output_video_filename =~ /$config->{image_sequence_dirname_prefix}/) {
    $output_video_filename =~ s/$config->{image_sequence_dirname_prefix }//;
  }
  while($output_video_filename =~ /$config->{image_name_prefix}/) {
    $output_video_filename =~ s/$config->{image_name_prefix}//;
  }

  my $config_codec = $config->{codecs}{$render_type->{codec}};
  my $quality_str = $config_codec->{filename}{quality};
  my $pix_fmt_short_str = $config_codec->{filename}{pixel_format};
  my $codec_for_filename = $config_codec->{filename}{codec};

  my $frame_rate = $render_type->{frame_rate};

  my $res_str = "OriRes";
  my $image_height = $render_type->{resolution}[1];
  if (defined $image_height) {
    $res_str = $image_height."p";
  }

  # prepend the format and file extention to the end of the filename
  $output_video_filename .= "_".$codec_for_filename."-$pix_fmt_short_str"."_Rec.709F_$res_str"."_$frame_rate"."_$quality_str.mov";

  return $output_video_filename;
}

# does this video file exist already or not?
sub should_render($$) {
  my ($config, $output_video_filename) = @_;

  # check for this file on the master render path
  my $should_render = 1;

  foreach my $master_video_dirname (@{$config->{master_videos}}) {
    if (-e "$master_video_dirname/$output_video_filename") {
      $should_render = 0;
    }
  }
  # check for this file on the temp render path
  foreach my $temp_dirname (@{$config->{temp_paths}}) {
    if (-e "$temp_dirname/$output_video_filename") {
      $should_render = 0;
    }
  }

  # make sure we've not already got a renderer setup for this video file
  foreach my $render_filename (keys %{$config->{renderer_map}}) {
    if($render_filename eq $output_video_filename) {
      $should_render = 0;
    }
  }

  return $should_render;
}

# render a video from the given image sequence for a render type (encoding, size, framerate)
# empty width and height default to original image resolution
sub create_renderer() {
  my ($config, $output_dirname, $image_sequence_name,
      $exif_data, $raw_sequence_length, $render_type, $group, $finished_callback) = @_;

  my $output_video_filename = output_video_filename($config, $render_type, $image_sequence_name);

  if(should_render($config, $output_video_filename)) {
    my $image_sequence_dirname = "$output_dirname/$image_sequence_name";

    my $image_width = $render_type->{resolution}[0];
    my $image_height = $render_type->{resolution}[1];

    opendir my $source_dir, $image_sequence_dirname or die "cannot open source dir $image_sequence_dirname: $!\n";

    my $test_image;

    # read all files at the first level of the source dir
    foreach my $filename (readdir $source_dir) {
      next if($filename =~ /^[.]/);
      $test_image = $filename;
      last;
    }
    my $image_type = ".tif";
    if ($test_image =~ /\d+(.*)$/) {
      $image_type = $1; # handle everything after the image index number
    }

    closedir $source_dir;

    my $should_resize = 1;

    # figure out if we're resizing when rendering or not
    unless (defined $image_width && defined $image_height) {
      # use original resolution unless given specific values
      my $exif = Exiftool::run("$image_sequence_dirname/$test_image");

      $image_width = $exif->{ImageWidth};
      $image_height = $exif->{ImageHeight};
      if ($image_width <= 0 || $image_height <= 0) {
	$log->timeLog($image_sequence_name, "cannot read image size from $image_sequence_dirname/$test_image, cannot not render [$image_width, $image_height]", 10);
	return undef;
      }
      $should_resize = 0;
    }

    # calculate aspect ratio from width/height
    my $aspect_ratio = Timelapse::get_aspect_ratio($image_width, $image_height);

    my $config_codec = $config->{codecs}{$render_type->{codec}};

    # these are ffmpeg params
    my $filter_str = "";
    my $pix_fmt_str = $config_codec->{ffmpeg}{pixel_format};
    my $color_range = $config_codec->{ffmpeg}{color_range};
    my $output_codec = $config_codec->{ffmpeg}{codec};
    my $frame_rate = $render_type->{frame_rate};
    if ($should_resize) {
      $filter_str = "-filter_complex 'crop=floor(iw/2)*2:floor(ih/2)*2,zscale=rangein=full:range=full:matrixin=709:matrix=709:primariesin=709:primaries=709:transferin=709:transfer=709:w=$image_width:h=$image_height,setsar=sar=1/1'";
    }

    # assemble render command
    # XXX hardcoded five digit sequence number index
    my $ffmpeg_cmd = "ffmpeg -y -r $frame_rate -i $image_sequence_dirname/$config->{image_name_prefix}%05d$image_type -aspect $aspect_ratio $filter_str -c:v $output_codec -pix_fmt $pix_fmt_str -threads 0 -profile:v 1 -movflags +write_colr -an -color_range $color_range -color_primaries bt709 -colorspace bt709 -color_trc bt709 ";

    # attach exif values
    foreach my $exif_key (keys %$exif_data) {
      my $exif_value = $exif_data->{$exif_key};
      $ffmpeg_cmd .= "-metadata '$exif_key=$exif_value' ";
    }

    $ffmpeg_cmd .= "$output_dirname/$output_video_filename";

    my $renderer = Renderer->new($log,
				 $ffmpeg_cmd,
				 $raw_sequence_length,
				 $output_dirname,
				 $output_video_filename,
				 $image_sequence_name,
				 $group,
				 $finished_callback);

    $config->{renderer_map}{$output_video_filename} = $renderer;
    push @$group, $renderer;

    return $renderer;
  } else {
    $log->timeLog($image_sequence_name, "$output_dirname/$output_video_filename already rendered", -1);
  }
}

my $exif_map = {};		# XXX move this

sub read_exif_json($$$) {
  my ($image_sequence_dirname, $base_dirname, $raw_image_sequence_name) = @_;

  my $exif_json_filename = "$base_dirname/$raw_image_sequence_name.json";
  my $image_sequence_exif = {};

  unless (-e $exif_json_filename) {
    return if $exif_map->{$exif_json_filename};

    $log->timeLog($image_sequence_dirname, "creating json exif file for $base_dirname/$raw_image_sequence_name", 10);

    $exif_map->{$exif_json_filename} = 1;
    my $dirname = "$base_dirname/$raw_image_sequence_name";

    opendir my $dir, $dirname or die "cannot open dir: $!\n";

    my $group = [];

    my $raw_filetypes = ['ARW', 'DNG']; # XXX fix hardcode

    foreach my $filename (readdir $dir) {
      my $is_raw = 0;
      foreach my $raw_filetype (@$raw_filetypes) {
	$is_raw = 1 if($filename =~ /$raw_filetype$/i);
      }
      next unless $is_raw;
      my $full_filename = "$dirname/$filename";
      my $runner = ExiftoolRunner->new($full_filename, $group, $exif_json_filename);
      $config->{exif_list}{$full_filename} = $runner;
      push @$group, $runner;
    }
    closedir $dir;
    return undef;
  }
  # hash ref
  my $exif_json = read_json_from($exif_json_filename);

  # remove keys with more than one value
  foreach my $exif_key (keys %$exif_json) {
    my @keys = keys %{$exif_json->{$exif_key}};
    my $num = scalar(@keys);
    if ($num == 1) {
      my $value = $keys[0];
      $image_sequence_exif->{$exif_key} = $value;
    }
  }
  return $image_sequence_exif;
}

# XXX copied from TimelapseExitool
sub read_json_from {
  my ($filename) = @_;

  my $json_text = do {
    open(my $json_fh, "<:encoding(UTF-8)", $filename)
      or warn ("Can't open \"$filename\": $!\n");
    local $/;
    <$json_fh>
  };

  my $ret = undef;
  if (defined $json_text) {
    eval {
      $ret = JSON->new->decode($json_text);
      1;
    } or do {
      warn "could not read json from $filename: $@";
    }
  }
  return $ret;
}

