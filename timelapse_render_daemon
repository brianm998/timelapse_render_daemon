#!/usr/bin/perl

# this script runs as a daemon to watch for timlapse sequences to render
# into videos, and renders them when they are ready, showing a running status
# update of what's going on.

use strict;
use File::Basename;
use Cwd;
use JSON;

my $script_dir;	# figure out where this running script exists on disk
BEGIN { $script_dir = Cwd::realpath( File::Basename::dirname(__FILE__)) }

# add this dir to the include path
use lib "${script_dir}/inc";

use UpdateableLog;

use lib '/Users/brian/iCloud/scripts'; # XXX this sucks :(
use TimelapseExiftool;

use lib '/Users/brian/git/timelapse_image_blender/inc'; # XXX fuck :(
use Timelapse;
use Exiftool;

# logic:
# read source path dirs and keep a record of name of dir and # of images

# look into temp_paths and try to find paths that match the name from
# source_dir, and have the right number of fully written output files,
# and don't have videos rendered in the temp or master_videos dirs with
# the same names as the config would end up producing

# once identified, render one or more videos based upon the config
# after each render, check to see if there is an exif json file for the
# source image sequence, if not, create it.
# apply this exif json file to the rendered videos

# keep running in daemon mode forever


# startup:

# - read source_dir, get initial list of image sequences and lengths


# daemon loop:

# - read source_dir, updating info on sequences and lengths
# - traverse temp_paths, looking for non-rendered videos
# - render non-existant videos
# - make json exif file if non existant
# - embed that into video

# todo:

# - expose things like frame rate to config
# - detangle depenency inc mess
# - support {year} in dirs?
# - notice when existing master video is older than the new sequence, and still render to temp path, assuming no file at temp path exists yet
# - allow rendering when base image sequence has been archived, based upon # of images from json
#   - specify archive locations in config
# - fix problem where deleting dirs makes them show up (tmp_rm hack works for now..)
# - add validation for Timelapse and others (ffmpeg exists, etc)
# - watch updates in config.json and update when running
# - write a real log file as well as the refreshing  console output
# - add config validation
# - avoid printing lines longer than the console

# all user visible output goes through this log
my $log = UpdateableLog->new();

# allow json config file to be referenced on the command line
my $config_json_filename = shift;

unless(defined $config_json_filename) {
  # if no config given on command line, default to this
  if(-e "$script_dir/config.json") {
    $config_json_filename = "$script_dir/config.json";
  } else {
    # XXX die with usage if no config present
    die;
  }
}

my $config = TimelapseExiftool::read_json_from($config_json_filename);

die unless ($config);
# XXX validate it

# an addressable list of what codecs we can encode to
$config->{codecs} = TimelapseExiftool::read_json_from("$script_dir/video_codecs.json");
# XXX validate that this is there and in right format
die unless ($config->{codecs});

# run once without renders to fully flesh out the display
search_image_sequences($config, 1);

while(1) {
  # search again and render if any image sequences are ready
  search_image_sequences($config, 0);

  # sleep and repeat
  sleep($config->{sleep_time_seconds})
}

########
# subs #
########


sub search_image_sequences($$$) {

  my ($config, $no_render, $currently_rendering_sequence_name) = @_;

  my $raw_image_sequences = read_raw_image_sequences($config);

  foreach my $temp_path (@{$config->{temp_paths}}) {
    opendir my $temp_dir, $temp_path or die "cannot open $temp_path: $!\n";

    foreach my $temp_entry (readdir $temp_dir) {
      next unless(-d "$temp_path/$temp_entry");
      my $raw_image_sequence_name = undef;

      foreach my $dirname (keys %$raw_image_sequences) {
	foreach my $raw_image_sequence (keys %{$raw_image_sequences->{$dirname}}) {
	  $raw_image_sequence_name = $raw_image_sequence
	    if ($temp_entry =~ /$config->{image_sequence_dirname_prefix}$raw_image_sequence/);
	}
      }
      next unless defined $raw_image_sequence_name;

      # check number of images
      opendir my $temp_dir, "$temp_path/$temp_entry" or die "cannot open dfs dir: $!\n";
      my $count = 0;
      foreach my $entry (readdir $temp_dir) {
	next if($entry =~ /^[.]/);
	next unless (-f "$temp_path/$temp_entry/$entry"); # only files
	 # files with .tif or .tiff extensions only
	if($entry !~ /[.]tiff?$/) { # XXX expose this in config so jpeg works too
	  next;
	}
	# what about jpeg?
	$count++; 		# assume everything else is an image
      }
      closedir $temp_dir;
      my $raw_sequence_length = undef;
      my $base_dirname = undef;
      foreach my $dirname (keys %$raw_image_sequences) {
	if (exists $raw_image_sequences->{$dirname}{$raw_image_sequence_name}) {
	  $raw_sequence_length = $raw_image_sequences->{$dirname}{$raw_image_sequence_name};
	  $base_dirname = $dirname;
	}
      }
      if($count == $raw_sequence_length) {
	my $video_write_json = {}; # exif data to write to video file

	my $would_render = undef;
	foreach my $render_type (@{$config->{rendering}}) {
	  # 1 means rendered
	  # 'error' means there was an error
	  # 0 means it was skipped because of existing video file of same name
	  my $should_render = render($config, $temp_path, $temp_entry, $video_write_json, $raw_sequence_length, $render_type, 1);
	  if ($should_render eq 'error') {
	    $would_render = 0;
	  } elsif (defined $would_render) {
	    $would_render = $should_render || $would_render;
	  } else {
	    $would_render = $should_render;
	  }
	}
	next if(!$would_render);
	my $sequence_size = sizeStringOf("$temp_path/$temp_entry");
	unless("$config->{image_sequence_dirname_prefix}$currently_rendering_sequence_name" eq $temp_entry) {
	  $log->timeLog($temp_entry, "$sequence_size image sequence $temp_path/$temp_entry is ready to render", 1);
	}
	next if($no_render);

	$log->timeLog($temp_entry, "rendering videos from $sequence_size image sequence $temp_path/$temp_entry", 10);

	# check here to see if we have a json file, if not, create it
	my $exif_json_filename = "$base_dirname/$raw_image_sequence_name.json";
	unless(-e $exif_json_filename) {
	  $log->log($temp_entry, "creating $exif_json_filename", 10);

	  my $exiftool = TimelapseExiftool->new;
	  my $json_str = $exiftool->json_for_raw_dir("$base_dirname/$raw_image_sequence_name");
	  open my $filehandle, ">$exif_json_filename" or die "can't open $exif_json_filename: $!\n";
	  print $filehandle $json_str;
	  close $filehandle;
	}
	# hash ref
	my $exif_json = TimelapseExiftool::read_json_from($exif_json_filename);

	# remove keys with more than one value
	foreach my $exif_key (keys %$exif_json) {
	  my @keys = keys %{$exif_json->{$exif_key}};
	  my $num = scalar(@keys);
	  if($num == 1) {
	    my $value = $keys[0];
	    $video_write_json->{$exif_key} = $value;
	  }
	}

	# attempt to render at each resolution,
	# existing output files will be skipped
	my $success = undef;

	foreach my $render_type (@{$config->{rendering}}) {
	  # 1 means rendered
	  # 'error' means there was an error
	  # 0 means it was skipped because of existing video file of same name
	  my $did_render = render($config, $temp_path, $temp_entry, $video_write_json, $raw_sequence_length, $render_type, 0);
	  if($did_render ne 'error') {
	    unless(defined $success) {
	      $success = $did_render;
	    }
	  } else {
	    $success = 0;
	  }
	}
	if($success) {
	  my $sequence_size = sizeStringOf("$temp_path/$temp_entry");
	  # maybe delete the image sequence after successful render
	  my $removed = 0;
	  foreach my $delete_regex (@{$config->{delete_sequence_after_render_regexes}}) {
	    if("$temp_path/$temp_entry" =~ /$delete_regex/) {
	      my $rm_cmd = "rm -rf $temp_path/$temp_entry";
	      $log->log($temp_entry, $rm_cmd, 10);
	      system($rm_cmd);
	      $removed = 1;
	      $log->timeLog($temp_entry, "done rendering videos from $sequence_size image sequence $temp_path/$temp_entry, image sequence removed", -1);
	    }
	  }
	  if(!$removed) {
	    $log->timeLog($temp_entry, "done rendering videos from $sequence_size image sequence $temp_path/$temp_entry", -1);
	  }
	}
      } else {
	# cannot process this one yet
	# log of how far along it is

	my $percentage = $count / $raw_sequence_length;
	my $progress_bar = progress_bar(30,  $percentage);

	my $frames_left = $raw_sequence_length - $count;
	my $msg = sprintf("(%04.d / %04.d) %04.d more",
			  $count, $raw_sequence_length,  $frames_left);
	my $sequence_size = sizeStringOf("$temp_path/$temp_entry/");

	# XXX this is a hack to align layers. usually 4 chars, add another when 3
	$sequence_size = " $sequence_size" if(length($sequence_size) == 3);

	$log->log($temp_entry, "$progress_bar $msg - $sequence_size $temp_path/$temp_entry", $percentage);
      }
    }
    closedir $temp_dir;
  }
}

# returns a hash of source path/entry to image count
sub read_raw_image_sequences($) {

  my ($config) = @_;

  my $raw_image_sequences = {};
  foreach my $source_path (@{$config->{source_paths}}) {
    opendir my $source_dir, $source_path or die "cannot open fuck $source_path: $!\n";

    foreach my $source_entry (readdir $source_dir) {
      next if($source_entry =~ /^[.]/);
      next unless(-d "$source_path/$source_entry");

      my $count = 0;
      opendir my $entry_dir, "$source_path/$source_entry" or die "cannot open shit dir: $!\n";

      foreach my $entry (readdir $entry_dir) {
	my $keep = 0;
	foreach my $raw_type (@{$config->{raw_types}}) {
	  $keep = 1 if($entry =~ /[.]$raw_type$/);
	}
	next unless $keep;
	$count++;
      }

      $raw_image_sequences->{$source_path}{$source_entry} = $count;
      #print "$source_path => $source_entry = $count\n";
    }
    closedir $source_dir;
  }
  return $raw_image_sequences;
}

# render a video from the given image sequence
# empty width and height default to original image resolution
sub render() {
  my ($config, $output_dirname, $image_sequence_name,
      $exif_data, $raw_sequence_length, $render_type, $check_only) = @_;

  my $image_sequence_dirname = "$output_dirname/$image_sequence_name";

  opendir my $source_dir, $image_sequence_dirname or die "cannot open source dir $image_sequence_dirname: $!\n";

  my $test_image;

  # read all files at the first level of the source dir
  foreach my $filename (readdir $source_dir) {
    next if($filename =~ /^[.]/);
    $test_image = $filename;
    last;
  }
  my $image_type = ".tif";
  if($test_image =~ /\d+(.*)$/) {
    $image_type = $1;		# handle everything after the image index number
  }

  closedir $source_dir;

  my $image_width = $render_type->{resolution}[0];
  my $image_height = $render_type->{resolution}[1];

  my $should_resize = 1;

  unless(defined $image_width && defined $image_height) {
    # use original resolution unless given specific values
    my $exif = Exiftool::run("$image_sequence_dirname/$test_image");

    $image_width = $exif->{ImageWidth};
    $image_height = $exif->{ImageHeight};
    if($image_width <= 0 || $image_height <= 0) {
      $log->log($image_sequence_name, "cannot read image size from $image_sequence_dirname/$test_image, cannot not render [$image_width, $image_height]", 10);
      return 'error';
    }
    $should_resize = 0;
  }

  # calculate aspect ratio from width/height
  my $aspect_ratio = Timelapse::get_aspect_ratio($image_width, $image_height);

  # remove the sequence image prefex if it happens to be part of the video filename
  while($image_sequence_name =~ /$config->{image_sequence_dirname_prefix}/) {
    $image_sequence_name =~ s/$config->{image_sequence_dirname_prefix }//;
  }
  while($image_sequence_name =~ /$config->{image_name_prefix}/) {
    $image_sequence_name =~ s/$config->{image_name_prefix}//;
  }
  my $output_video_filename = $image_sequence_name;

  my $res_str = "OriRes";
  my $config_codec = $config->{codecs}{$render_type->{codec}};
  my $quality_str = $config_codec->{filename}{quality};
  my $pix_fmt_short_str = $config_codec->{filename}{pixel_format};
  my $codec_for_filename = $config_codec->{filename}{codec};

  # these are ffmpeg params
  my $filter_str = "";
  my $pix_fmt_str = $config_codec->{ffmpeg}{pixel_format};
  my $frame_rate = $render_type->{frame_rate};
  my $color_range = $config_codec->{ffmpeg}{color_range};
  my $output_codec = $config_codec->{ffmpeg}{codec};
  if ($should_resize) {
    $filter_str = "-filter_complex 'crop=floor(iw/2)*2:floor(ih/2)*2,zscale=rangein=full:range=full:matrixin=709:matrix=709:primariesin=709:primaries=709:transferin=709:transfer=709:w=$image_width:h=$image_height,setsar=sar=1/1'";
    $res_str = $image_height."p";
  }

  # prepend the format and file extention to the end of the filename
  $output_video_filename .= "_".$codec_for_filename."-$pix_fmt_short_str"."_Rec.709F_$res_str"."_$frame_rate"."_$quality_str.mov";

  # check for this file on the master render path
  my $should_render = 1;

  foreach my $master_video_dirname (@{$config->{master_videos}}) {
    if (-e "$master_video_dirname/$output_video_filename") {
      #print("$master_video_dirname/$output_video_filename already exists, will not render\n");
      $should_render = 0;
    }
  }
  # check for this file on the temp render path
  foreach my $temp_dirname (@{$config->{temp_paths}}) {
    if (-e "$temp_dirname/$output_video_filename") {
      #print("$temp_dirname/$output_video_filename already exists, cannot render\n");
      $should_render = 0;
    }
  }
  return $should_render if($check_only);

  if($should_render) {
    # assemble render command
    # XXX hardcoded five digit sequence number index
    my $ffmpeg_cmd = "ffmpeg -y -r $frame_rate -i $image_sequence_dirname/$config->{image_name_prefix}%05d$image_type -aspect $aspect_ratio $filter_str -c:v $output_codec -pix_fmt $pix_fmt_str -threads 0 -profile:v 1 -movflags +write_colr -an -color_range $color_range -color_primaries bt709 -colorspace bt709 -color_trc bt709 ";

    # attach exif values
    foreach my $exif_key (keys %$exif_data) {
      my $exif_value = $exif_data->{$exif_key};
      $ffmpeg_cmd .= "-metadata '$exif_key=$exif_value' ";
    }

    $ffmpeg_cmd .= "$output_dirname/$output_video_filename";
    $log->log($output_video_filename, "starting render of $output_video_filename", 10);
    open FFMPEG, "$ffmpeg_cmd 2>&1 |";
    my $frame_num = 0;
    my $last_update = 0;
    my $update_after_frames = 2;  # how many frames pass before we update the rest of the display
    $/ = "";			  # don't use newline for <>
    while(<FFMPEG>) {
      # frame= 1569 fps=0.9 q=-0.0 Lsize=  286475kB time=00:00:52.26 bitrate=44900.6kbits/s speed=0.0292x 
      if(/^frame=\s+(\d+)\s+fps=([\d.]+)/) {
	$frame_num = $1;
	my $fps = $2;
	my $progress_percentage = $frame_num / $raw_sequence_length;

	my $progress_bar = progress_bar(30, $progress_percentage);

	$progress_bar .= " rendering frame $frame_num/$raw_sequence_length ($fps fps) for";
	$log->log($output_video_filename, "$progress_bar $output_video_filename", 10);
	if ($frame_num - $last_update > $update_after_frames) {
	  $/ = "\n";		# just incase any method called here uses <> expecting \n
	  # called to update image sequence progress, no extra render here
	  search_image_sequences($config, 1, $image_sequence_name);
	  $last_update = $frame_num;
	  $/ = "";
	}
      }
    }
    $/ = "\n";
    my $result = close FFMPEG;
    if ($result == 1) {
      my $video_size = sizeStringOf("$output_dirname/$output_video_filename");
      $log->timeLog($output_video_filename, "rendered $video_size $frame_num frame $output_dirname/$output_video_filename", -1);
      return 1;
    } else {
      # failed, why?
      $log->timeLog($output_video_filename, "$output_dirname/$output_video_filename render FAILED", -1);
      return 'error';
    }
  } else {
    $log->log($image_sequence_name, "$image_sequence_name already rendered", -1);
  }
  return 0;
}

sub progress_bar($$) {
  my ($length, $percentage) = @_;

  my $progress_bar = "[";
  for (my $i = 0 ; $i < $length ; $i++) {
    if ($i/$length < $percentage) {
      $progress_bar .= '*';
    } else {
      $progress_bar .= '-';
    }
  }
  $progress_bar .= "]";

  return $progress_bar;
}

# a human readable string giving the size of a file (or total of a shell globbed list)
# XXX copied from backup.pl :(
sub sizeStringOf {
  my ($item) = @_;
  open DU, "du -ch $item |";
  while (<DU>) { return $1 if $_ =~ /^\s*([\d\w.]+)\s+total/; }
  close DU;
}
